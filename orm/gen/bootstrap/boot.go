package bootstrap

import (
	"bytes"
	"d3/cmd/d3/parser"
	"go/format"
	"html/template"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
)

const aliasPrefix = "D3_entity_"

type Generator struct {
	PkgPath, PkgName string
	Metas            []parser.EntityMeta
	OutName          string
	BuildTags        string
	Debug            bool
}

func (g *Generator) writeAlias() (string, error) {
	f, err := ioutil.TempFile(filepath.Dir(g.OutName), "d3alias")
	if err != nil {
		return "", err
	}
	defer f.Close()

	t, err := template.New("aliasing").Parse(`
// TEMPORARY AUTOGENERATED

package {{.pkg}}

{{$pref := .Prefix}}

{{range .metas}}
type {{$pref}}{{.Name}} *{{.Name}}
{{end}}
`)
	if err != nil {
		return "", err
	}

	if err := t.Execute(f, map[string]interface{}{"pkg": g.PkgName, "Prefix": aliasPrefix, "metas": g.Metas}); err != nil {
		return "", err
	}

	err = os.Rename(f.Name(), f.Name()+".go")
	return f.Name() + ".go", err
}

// writeMain creates a .go file that launches the generator if 'go run'.
func (g *Generator) writeMain() (path string, err error) {
	f, err := ioutil.TempFile(filepath.Dir(g.OutName), "d3boot")
	if err != nil {
		return "", err
	}
	defer f.Close()

	t, err := template.New("aliasing").Parse(`
// +build ignore

// TEMPORARY AUTOGENERATED

package main

import (
	"fmt"
	"os"
	"reflect"
	"d3/orm/gen"
	al "{{.PkgPath}}"
)

func main() {
	fmt.Fprintf(os.Stdout, "// Code generated by d3. DO NOT EDIT.\n\n")
	fmt.Fprintf(os.Stdout, "package {{.PkgName}}\n")
	g := gen.NewGenerator(os.Stdout, "{{.PkgPath}}")
	{{$pref := .Prefix}}
	{{range .metas}}
	g.Prepare(reflect.TypeOf(al.{{$pref}}{{.Name}}(nil)), "{{.TableName}}")
	{{end}}
	g.Write()
}
`)
	if err != nil {
		return "", err
	}

	if err := t.Execute(f, map[string]interface{}{"PkgPath": g.PkgPath, "Prefix": aliasPrefix, "PkgName": g.PkgName, "metas": g.Metas}); err != nil {
		return "", err
	}

	err = os.Rename(f.Name(), f.Name()+".go")
	return f.Name() + ".go", err
}

func (g *Generator) Run() error {
	aliasFile, err := g.writeAlias()
	if err != nil {
		return err
	}
	defer g.removeIfNeeded(aliasFile)

	path, err := g.writeMain()
	if err != nil {
		return err
	}
	defer g.removeIfNeeded(path)

	codeBuff := &bytes.Buffer{}

	cmd := exec.Command("go", "run", "-tags", g.BuildTags, filepath.Base(path))
	cmd.Stdout = codeBuff
	cmd.Stderr = os.Stderr
	cmd.Dir = filepath.Dir(path)
	if err = cmd.Run(); err != nil {
		return err
	}

	out, err := format.Source(codeBuff.Bytes())
	if err != nil {
		return err
	}

	return ioutil.WriteFile(g.OutName, out, 0644)
}

func (g *Generator) removeIfNeeded(filename string) {
	if !g.Debug {
		_ = os.Remove(filename)
	}
}
