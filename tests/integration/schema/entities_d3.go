// Code generated by d3. DO NOT EDIT.

package schema

import "fmt"
import "github.com/godzie44/d3/orm/entity"
import "time"
import "database/sql/driver"

func (s *shop) D3Token() entity.MetaToken {
	return entity.MetaToken{
		Tpl:       (*shop)(nil),
		TableName: "shop_m",
		Tools: entity.InternalTools{
			ExtractField:  s.__d3_makeFieldExtractor(),
			SetFieldVal:   s.__d3_makeFieldSetter(),
			CompareFields: s.__d3_makeComparator(),
			NewInstance:   s.__d3_makeInstantiator(),
			Copy:          s.__d3_makeCopier(),
		},
	}
}

func (s *shop) __d3_makeFieldExtractor() entity.FieldExtractor {
	return func(s interface{}, name string) (interface{}, error) {
		sTyped, ok := s.(*shop)
		if !ok {
			return nil, fmt.Errorf("invalid entity type")
		}

		switch name {

		case "Id":
			return sTyped.Id, nil

		case "Books":
			return sTyped.Books, nil

		case "Profile":
			return sTyped.Profile, nil

		case "Name":
			return sTyped.Name, nil

		default:
			return nil, fmt.Errorf("field %s not found", name)
		}
	}
}

func (s *shop) __d3_makeInstantiator() entity.Instantiator {
	return func() interface{} {
		return &shop{}
	}
}

func (s *shop) __d3_makeFieldSetter() entity.FieldSetter {
	return func(s interface{}, name string, val interface{}) error {
		eTyped, ok := s.(*shop)
		if !ok {
			return fmt.Errorf("invalid entity type")
		}

		switch name {
		case "Books":
			eTyped.Books = val.(*entity.Collection)
			return nil
		case "Profile":
			eTyped.Profile = val.(*entity.Cell)
			return nil
		case "Name":
			eTyped.Name = val.(string)
			return nil

		case "Id":
			if valuer, isValuer := val.(driver.Valuer); isValuer {
				v, err := valuer.Value()
				if err != nil {
					return eTyped.Id.Scan(nil)
				}
				return eTyped.Id.Scan(v)
			}
			return eTyped.Id.Scan(val)
		default:
			return fmt.Errorf("field %s not found", name)
		}
	}
}

func (s *shop) __d3_makeCopier() entity.Copier {
	return func(src interface{}) interface{} {
		srcTyped, ok := src.(*shop)
		if !ok {
			return fmt.Errorf("invalid entity type")
		}

		copy := &shop{}

		copy.Id = srcTyped.Id
		copy.Name = srcTyped.Name

		if srcTyped.Books != nil {
			copy.Books = srcTyped.Books.DeepCopy().(*entity.Collection)
		}
		if srcTyped.Profile != nil {
			copy.Profile = srcTyped.Profile.DeepCopy().(*entity.Cell)
		}

		return copy
	}
}

func (s *shop) __d3_makeComparator() entity.FieldComparator {
	return func(e1, e2 interface{}, fName string) bool {
		if e1 == nil || e2 == nil {
			return e1 == e2
		}

		e1Typed, ok := e1.(*shop)
		if !ok {
			return false
		}
		e2Typed, ok := e2.(*shop)
		if !ok {
			return false
		}

		switch fName {

		case "Id":
			return e1Typed.Id == e2Typed.Id
		case "Books":
			return e1Typed.Books == e2Typed.Books
		case "Profile":
			return e1Typed.Profile == e2Typed.Profile
		case "Name":
			return e1Typed.Name == e2Typed.Name
		default:
			return false
		}
	}
}

func (p *profile) D3Token() entity.MetaToken {
	return entity.MetaToken{
		Tpl:       (*profile)(nil),
		TableName: "profile_m",
		Tools: entity.InternalTools{
			ExtractField:  p.__d3_makeFieldExtractor(),
			SetFieldVal:   p.__d3_makeFieldSetter(),
			CompareFields: p.__d3_makeComparator(),
			NewInstance:   p.__d3_makeInstantiator(),
			Copy:          p.__d3_makeCopier(),
		},
	}
}

func (p *profile) __d3_makeFieldExtractor() entity.FieldExtractor {
	return func(s interface{}, name string) (interface{}, error) {
		sTyped, ok := s.(*profile)
		if !ok {
			return nil, fmt.Errorf("invalid entity type")
		}

		switch name {

		case "Id":
			return sTyped.Id, nil

		case "Description":
			return sTyped.Description, nil

		default:
			return nil, fmt.Errorf("field %s not found", name)
		}
	}
}

func (p *profile) __d3_makeInstantiator() entity.Instantiator {
	return func() interface{} {
		return &profile{}
	}
}

func (p *profile) __d3_makeFieldSetter() entity.FieldSetter {
	return func(s interface{}, name string, val interface{}) error {
		eTyped, ok := s.(*profile)
		if !ok {
			return fmt.Errorf("invalid entity type")
		}

		switch name {
		case "Description":
			eTyped.Description = val.(string)
			return nil

		case "Id":
			if valuer, isValuer := val.(driver.Valuer); isValuer {
				v, err := valuer.Value()
				if err != nil {
					return eTyped.Id.Scan(nil)
				}
				return eTyped.Id.Scan(v)
			}
			return eTyped.Id.Scan(val)
		default:
			return fmt.Errorf("field %s not found", name)
		}
	}
}

func (p *profile) __d3_makeCopier() entity.Copier {
	return func(src interface{}) interface{} {
		srcTyped, ok := src.(*profile)
		if !ok {
			return fmt.Errorf("invalid entity type")
		}

		copy := &profile{}

		copy.Id = srcTyped.Id
		copy.Description = srcTyped.Description

		return copy
	}
}

func (p *profile) __d3_makeComparator() entity.FieldComparator {
	return func(e1, e2 interface{}, fName string) bool {
		if e1 == nil || e2 == nil {
			return e1 == e2
		}

		e1Typed, ok := e1.(*profile)
		if !ok {
			return false
		}
		e2Typed, ok := e2.(*profile)
		if !ok {
			return false
		}

		switch fName {

		case "Id":
			return e1Typed.Id == e2Typed.Id
		case "Description":
			return e1Typed.Description == e2Typed.Description
		default:
			return false
		}
	}
}

func (b *book) D3Token() entity.MetaToken {
	return entity.MetaToken{
		Tpl:       (*book)(nil),
		TableName: "book_m",
		Tools: entity.InternalTools{
			ExtractField:  b.__d3_makeFieldExtractor(),
			SetFieldVal:   b.__d3_makeFieldSetter(),
			CompareFields: b.__d3_makeComparator(),
			NewInstance:   b.__d3_makeInstantiator(),
			Copy:          b.__d3_makeCopier(),
		},
	}
}

func (b *book) __d3_makeFieldExtractor() entity.FieldExtractor {
	return func(s interface{}, name string) (interface{}, error) {
		sTyped, ok := s.(*book)
		if !ok {
			return nil, fmt.Errorf("invalid entity type")
		}

		switch name {

		case "Id":
			return sTyped.Id, nil

		case "Authors":
			return sTyped.Authors, nil

		case "Name":
			return sTyped.Name, nil

		default:
			return nil, fmt.Errorf("field %s not found", name)
		}
	}
}

func (b *book) __d3_makeInstantiator() entity.Instantiator {
	return func() interface{} {
		return &book{}
	}
}

func (b *book) __d3_makeFieldSetter() entity.FieldSetter {
	return func(s interface{}, name string, val interface{}) error {
		eTyped, ok := s.(*book)
		if !ok {
			return fmt.Errorf("invalid entity type")
		}

		switch name {
		case "Authors":
			eTyped.Authors = val.(*entity.Collection)
			return nil
		case "Name":
			eTyped.Name = val.(string)
			return nil

		case "Id":
			if valuer, isValuer := val.(driver.Valuer); isValuer {
				v, err := valuer.Value()
				if err != nil {
					return eTyped.Id.Scan(nil)
				}
				return eTyped.Id.Scan(v)
			}
			return eTyped.Id.Scan(val)
		default:
			return fmt.Errorf("field %s not found", name)
		}
	}
}

func (b *book) __d3_makeCopier() entity.Copier {
	return func(src interface{}) interface{} {
		srcTyped, ok := src.(*book)
		if !ok {
			return fmt.Errorf("invalid entity type")
		}

		copy := &book{}

		copy.Id = srcTyped.Id
		copy.Name = srcTyped.Name

		if srcTyped.Authors != nil {
			copy.Authors = srcTyped.Authors.DeepCopy().(*entity.Collection)
		}

		return copy
	}
}

func (b *book) __d3_makeComparator() entity.FieldComparator {
	return func(e1, e2 interface{}, fName string) bool {
		if e1 == nil || e2 == nil {
			return e1 == e2
		}

		e1Typed, ok := e1.(*book)
		if !ok {
			return false
		}
		e2Typed, ok := e2.(*book)
		if !ok {
			return false
		}

		switch fName {

		case "Id":
			return e1Typed.Id == e2Typed.Id
		case "Authors":
			return e1Typed.Authors == e2Typed.Authors
		case "Name":
			return e1Typed.Name == e2Typed.Name
		default:
			return false
		}
	}
}

func (a *author) D3Token() entity.MetaToken {
	return entity.MetaToken{
		Tpl:       (*author)(nil),
		TableName: "author_m",
		Tools: entity.InternalTools{
			ExtractField:  a.__d3_makeFieldExtractor(),
			SetFieldVal:   a.__d3_makeFieldSetter(),
			CompareFields: a.__d3_makeComparator(),
			NewInstance:   a.__d3_makeInstantiator(),
			Copy:          a.__d3_makeCopier(),
		},
	}
}

func (a *author) __d3_makeFieldExtractor() entity.FieldExtractor {
	return func(s interface{}, name string) (interface{}, error) {
		sTyped, ok := s.(*author)
		if !ok {
			return nil, fmt.Errorf("invalid entity type")
		}

		switch name {

		case "Id":
			return sTyped.Id, nil

		case "Name":
			return sTyped.Name, nil

		default:
			return nil, fmt.Errorf("field %s not found", name)
		}
	}
}

func (a *author) __d3_makeInstantiator() entity.Instantiator {
	return func() interface{} {
		return &author{}
	}
}

func (a *author) __d3_makeFieldSetter() entity.FieldSetter {
	return func(s interface{}, name string, val interface{}) error {
		eTyped, ok := s.(*author)
		if !ok {
			return fmt.Errorf("invalid entity type")
		}

		switch name {
		case "Name":
			eTyped.Name = val.(string)
			return nil

		case "Id":
			if valuer, isValuer := val.(driver.Valuer); isValuer {
				v, err := valuer.Value()
				if err != nil {
					return eTyped.Id.Scan(nil)
				}
				return eTyped.Id.Scan(v)
			}
			return eTyped.Id.Scan(val)
		default:
			return fmt.Errorf("field %s not found", name)
		}
	}
}

func (a *author) __d3_makeCopier() entity.Copier {
	return func(src interface{}) interface{} {
		srcTyped, ok := src.(*author)
		if !ok {
			return fmt.Errorf("invalid entity type")
		}

		copy := &author{}

		copy.Id = srcTyped.Id
		copy.Name = srcTyped.Name

		return copy
	}
}

func (a *author) __d3_makeComparator() entity.FieldComparator {
	return func(e1, e2 interface{}, fName string) bool {
		if e1 == nil || e2 == nil {
			return e1 == e2
		}

		e1Typed, ok := e1.(*author)
		if !ok {
			return false
		}
		e2Typed, ok := e2.(*author)
		if !ok {
			return false
		}

		switch fName {

		case "Id":
			return e1Typed.Id == e2Typed.Id
		case "Name":
			return e1Typed.Name == e2Typed.Name
		default:
			return false
		}
	}
}

func (a *allTypeStruct) D3Token() entity.MetaToken {
	return entity.MetaToken{
		Tpl:       (*allTypeStruct)(nil),
		TableName: "all_types",
		Tools: entity.InternalTools{
			ExtractField:  a.__d3_makeFieldExtractor(),
			SetFieldVal:   a.__d3_makeFieldSetter(),
			CompareFields: a.__d3_makeComparator(),
			NewInstance:   a.__d3_makeInstantiator(),
			Copy:          a.__d3_makeCopier(),
		},
	}
}

func (a *allTypeStruct) __d3_makeFieldExtractor() entity.FieldExtractor {
	return func(s interface{}, name string) (interface{}, error) {
		sTyped, ok := s.(*allTypeStruct)
		if !ok {
			return nil, fmt.Errorf("invalid entity type")
		}

		switch name {

		case "ID":
			return sTyped.ID, nil

		case "Uuid":
			return sTyped.Uuid, nil

		case "BoolField":
			return sTyped.BoolField, nil

		case "IntField":
			return sTyped.IntField, nil

		case "Int32Field":
			return sTyped.Int32Field, nil

		case "Int64Field":
			return sTyped.Int64Field, nil

		case "Float32Field":
			return sTyped.Float32Field, nil

		case "Float64Field":
			return sTyped.Float64Field, nil

		case "StringField":
			return sTyped.StringField, nil

		case "TimeField":
			return sTyped.TimeField, nil

		case "NullBoolField":
			return sTyped.NullBoolField, nil

		case "NullI32Field":
			return sTyped.NullI32Field, nil

		case "NullI64Field":
			return sTyped.NullI64Field, nil

		case "NullFloat64Field":
			return sTyped.NullFloat64Field, nil

		case "NullStringField":
			return sTyped.NullStringField, nil

		case "NullTimeField":
			return sTyped.NullTimeField, nil

		default:
			return nil, fmt.Errorf("field %s not found", name)
		}
	}
}

func (a *allTypeStruct) __d3_makeInstantiator() entity.Instantiator {
	return func() interface{} {
		return &allTypeStruct{}
	}
}

func (a *allTypeStruct) __d3_makeFieldSetter() entity.FieldSetter {
	return func(s interface{}, name string, val interface{}) error {
		eTyped, ok := s.(*allTypeStruct)
		if !ok {
			return fmt.Errorf("invalid entity type")
		}

		switch name {
		case "BoolField":
			eTyped.BoolField = val.(bool)
			return nil
		case "IntField":
			eTyped.IntField = val.(int)
			return nil
		case "Int32Field":
			eTyped.Int32Field = val.(int32)
			return nil
		case "Int64Field":
			eTyped.Int64Field = val.(int64)
			return nil
		case "Float32Field":
			eTyped.Float32Field = val.(float32)
			return nil
		case "Float64Field":
			eTyped.Float64Field = val.(float64)
			return nil
		case "StringField":
			eTyped.StringField = val.(string)
			return nil
		case "TimeField":
			eTyped.TimeField = val.(time.Time)
			return nil

		case "ID":
			if valuer, isValuer := val.(driver.Valuer); isValuer {
				v, err := valuer.Value()
				if err != nil {
					return eTyped.ID.Scan(nil)
				}
				return eTyped.ID.Scan(v)
			}
			return eTyped.ID.Scan(val)
		case "Uuid":
			if valuer, isValuer := val.(driver.Valuer); isValuer {
				v, err := valuer.Value()
				if err != nil {
					return eTyped.Uuid.Scan(nil)
				}
				return eTyped.Uuid.Scan(v)
			}
			return eTyped.Uuid.Scan(val)
		case "NullBoolField":
			if valuer, isValuer := val.(driver.Valuer); isValuer {
				v, err := valuer.Value()
				if err != nil {
					return eTyped.NullBoolField.Scan(nil)
				}
				return eTyped.NullBoolField.Scan(v)
			}
			return eTyped.NullBoolField.Scan(val)
		case "NullI32Field":
			if valuer, isValuer := val.(driver.Valuer); isValuer {
				v, err := valuer.Value()
				if err != nil {
					return eTyped.NullI32Field.Scan(nil)
				}
				return eTyped.NullI32Field.Scan(v)
			}
			return eTyped.NullI32Field.Scan(val)
		case "NullI64Field":
			if valuer, isValuer := val.(driver.Valuer); isValuer {
				v, err := valuer.Value()
				if err != nil {
					return eTyped.NullI64Field.Scan(nil)
				}
				return eTyped.NullI64Field.Scan(v)
			}
			return eTyped.NullI64Field.Scan(val)
		case "NullFloat64Field":
			if valuer, isValuer := val.(driver.Valuer); isValuer {
				v, err := valuer.Value()
				if err != nil {
					return eTyped.NullFloat64Field.Scan(nil)
				}
				return eTyped.NullFloat64Field.Scan(v)
			}
			return eTyped.NullFloat64Field.Scan(val)
		case "NullStringField":
			if valuer, isValuer := val.(driver.Valuer); isValuer {
				v, err := valuer.Value()
				if err != nil {
					return eTyped.NullStringField.Scan(nil)
				}
				return eTyped.NullStringField.Scan(v)
			}
			return eTyped.NullStringField.Scan(val)
		case "NullTimeField":
			if valuer, isValuer := val.(driver.Valuer); isValuer {
				v, err := valuer.Value()
				if err != nil {
					return eTyped.NullTimeField.Scan(nil)
				}
				return eTyped.NullTimeField.Scan(v)
			}
			return eTyped.NullTimeField.Scan(val)
		default:
			return fmt.Errorf("field %s not found", name)
		}
	}
}

func (a *allTypeStruct) __d3_makeCopier() entity.Copier {
	return func(src interface{}) interface{} {
		srcTyped, ok := src.(*allTypeStruct)
		if !ok {
			return fmt.Errorf("invalid entity type")
		}

		copy := &allTypeStruct{}

		copy.ID = srcTyped.ID
		copy.Uuid = srcTyped.Uuid
		copy.BoolField = srcTyped.BoolField
		copy.IntField = srcTyped.IntField
		copy.Int32Field = srcTyped.Int32Field
		copy.Int64Field = srcTyped.Int64Field
		copy.Float32Field = srcTyped.Float32Field
		copy.Float64Field = srcTyped.Float64Field
		copy.StringField = srcTyped.StringField
		copy.TimeField = srcTyped.TimeField
		copy.NullBoolField = srcTyped.NullBoolField
		copy.NullI32Field = srcTyped.NullI32Field
		copy.NullI64Field = srcTyped.NullI64Field
		copy.NullFloat64Field = srcTyped.NullFloat64Field
		copy.NullStringField = srcTyped.NullStringField
		copy.NullTimeField = srcTyped.NullTimeField

		return copy
	}
}

func (a *allTypeStruct) __d3_makeComparator() entity.FieldComparator {
	return func(e1, e2 interface{}, fName string) bool {
		if e1 == nil || e2 == nil {
			return e1 == e2
		}

		e1Typed, ok := e1.(*allTypeStruct)
		if !ok {
			return false
		}
		e2Typed, ok := e2.(*allTypeStruct)
		if !ok {
			return false
		}

		switch fName {

		case "ID":
			return e1Typed.ID == e2Typed.ID
		case "Uuid":
			return e1Typed.Uuid == e2Typed.Uuid
		case "BoolField":
			return e1Typed.BoolField == e2Typed.BoolField
		case "IntField":
			return e1Typed.IntField == e2Typed.IntField
		case "Int32Field":
			return e1Typed.Int32Field == e2Typed.Int32Field
		case "Int64Field":
			return e1Typed.Int64Field == e2Typed.Int64Field
		case "Float32Field":
			return e1Typed.Float32Field == e2Typed.Float32Field
		case "Float64Field":
			return e1Typed.Float64Field == e2Typed.Float64Field
		case "StringField":
			return e1Typed.StringField == e2Typed.StringField
		case "TimeField":
			return e1Typed.TimeField == e2Typed.TimeField
		case "NullBoolField":
			return e1Typed.NullBoolField == e2Typed.NullBoolField
		case "NullI32Field":
			return e1Typed.NullI32Field == e2Typed.NullI32Field
		case "NullI64Field":
			return e1Typed.NullI64Field == e2Typed.NullI64Field
		case "NullFloat64Field":
			return e1Typed.NullFloat64Field == e2Typed.NullFloat64Field
		case "NullStringField":
			return e1Typed.NullStringField == e2Typed.NullStringField
		case "NullTimeField":
			return e1Typed.NullTimeField == e2Typed.NullTimeField
		default:
			return false
		}
	}
}

func (e *entityWithAliases) D3Token() entity.MetaToken {
	return entity.MetaToken{
		Tpl:       (*entityWithAliases)(nil),
		TableName: "test_aliases",
		Tools: entity.InternalTools{
			ExtractField:  e.__d3_makeFieldExtractor(),
			SetFieldVal:   e.__d3_makeFieldSetter(),
			CompareFields: e.__d3_makeComparator(),
			NewInstance:   e.__d3_makeInstantiator(),
			Copy:          e.__d3_makeCopier(),
		},
	}
}

func (e *entityWithAliases) __d3_makeFieldExtractor() entity.FieldExtractor {
	return func(s interface{}, name string) (interface{}, error) {
		sTyped, ok := s.(*entityWithAliases)
		if !ok {
			return nil, fmt.Errorf("invalid entity type")
		}

		switch name {

		case "ID":
			return sTyped.ID, nil

		case "email":
			return sTyped.email, nil

		case "secretEmail":
			return sTyped.secretEmail, nil

		default:
			return nil, fmt.Errorf("field %s not found", name)
		}
	}
}

func (e *entityWithAliases) __d3_makeInstantiator() entity.Instantiator {
	return func() interface{} {
		return &entityWithAliases{}
	}
}

func (e *entityWithAliases) __d3_makeFieldSetter() entity.FieldSetter {
	return func(s interface{}, name string, val interface{}) error {
		eTyped, ok := s.(*entityWithAliases)
		if !ok {
			return fmt.Errorf("invalid entity type")
		}

		switch name {

		case "email":
			eTyped.email = Email(val.(string))
			return nil
		case "secretEmail":
			eTyped.secretEmail = myEmail(val.(string))
			return nil

		case "ID":
			if valuer, isValuer := val.(driver.Valuer); isValuer {
				v, err := valuer.Value()
				if err != nil {
					return eTyped.ID.Scan(nil)
				}
				return eTyped.ID.Scan(v)
			}
			return eTyped.ID.Scan(val)
		default:
			return fmt.Errorf("field %s not found", name)
		}
	}
}

func (e *entityWithAliases) __d3_makeCopier() entity.Copier {
	return func(src interface{}) interface{} {
		srcTyped, ok := src.(*entityWithAliases)
		if !ok {
			return fmt.Errorf("invalid entity type")
		}

		copy := &entityWithAliases{}

		copy.ID = srcTyped.ID
		copy.email = srcTyped.email
		copy.secretEmail = srcTyped.secretEmail

		return copy
	}
}

func (e *entityWithAliases) __d3_makeComparator() entity.FieldComparator {
	return func(e1, e2 interface{}, fName string) bool {
		if e1 == nil || e2 == nil {
			return e1 == e2
		}

		e1Typed, ok := e1.(*entityWithAliases)
		if !ok {
			return false
		}
		e2Typed, ok := e2.(*entityWithAliases)
		if !ok {
			return false
		}

		switch fName {

		case "ID":
			return e1Typed.ID == e2Typed.ID
		case "email":
			return e1Typed.email == e2Typed.email
		case "secretEmail":
			return e1Typed.secretEmail == e2Typed.secretEmail
		default:
			return false
		}
	}
}
